# LAMMPS Input Script for Rigid Patchy Monomers with State Changes
# Generated by Python script on 2025-11-25T18:22:28
# Uses custom C++ fix state/change (NO unfix/refix required!)
# Using LAMMPS built-in morse and lj/cut potentials (from successful test)

# 1. Initialization
units           lj
atom_style      molecular
boundary        p p p
newton          on

# 2. Atom Definition
read_data       data.rigid_patchy_monomers

# 2.5. Expand box by 5% and remap atoms
change_box      all x scale 1.05 remap
change_box      all y scale 1.05 remap
change_box      all z scale 1.05 remap

# 3. Force Field Parameters
# Using LAMMPS built-in potentials (morse and lj/cut) for better reliability
# This matches the successful test simulation configuration
pair_style      hybrid/overlay morse 4.0 lj/cut 2.0
# STRONG ATTRACTION with type 2-2 (500.0) being stronger than 3-3 (300.0)
# Morse potential for patch-patch: 
#   - Type 2-2: D0=20.0, alpha=10.0, r0=0.0, rcut=4.0
#   - Type 3-3: D0=20.0, alpha=10.0, r0=0.0, rcut=4.0
# Moderate attraction - patches can form dimers but not overly strong
# Patches must overlap (coordination cutoff=0.34) for state change
# Type 2-2: D0=500.0 gives: extremely strong at r=0.0 (-500.0), very strong at r=0.2 (-335.0), strong at r=0.34 (-150.0)
# Type 3-3: D0=300.0 gives: extremely strong at r=0.0 (-300.0), very strong at r=0.2 (-201.0), strong at r=0.34 (-90.0)
# This creates a strong pulling force when patches are close, with type 2-2 being stronger than 3-3
# REPULSION: rep_epsilon=50.0 (further reduced from 100.0) for even easier approach
pair_coeff      2 2 morse 20.0 10.0 0.0 4.0
pair_coeff      3 3 morse 20.0 10.0 0.0 4.0
# Lennard-Jones for repulsion: body-body (1-1) only (NO body-patch interactions)
pair_coeff      1 1 lj/cut 50.0 1.0 2.0
# NOTE: Removed body-patch interactions (1-2, 1-3) as requested
# Set all other combinations to zero (no interaction)
pair_coeff      * * morse 0.0 1.0 1.0 1.0
pair_coeff      * * lj/cut 0.0 1.0 1.0
# NOTE: NO repulsion for 2-2, 2-3, 3-3 - patches can overlap with attraction dominating

# 4. Rigid Body Definition (temporary, for minimization)
fix             rigid_temp all rigid molecule

# 5. Simulation Settings
# Enhanced neighbor list settings for strong attractions
# Neighbor skin to match rcut (rcut=4.0, so need skin > 4.0)
neighbor        4.5 bin  # Skin distance to match rcut=4.0
neigh_modify    delay 0 every 1 check yes page 200000 one 20000
comm_style      brick
comm_modify     vel yes cutoff 4.5

# 5.5. Minimize (critical for stability with strong attractions)
# More thorough minimization to eliminate unfavorable configurations (from successful test)
minimize        1.0e-4 1.0e-6 100 1000

# 5.6. Reset timestep
reset_timestep  0

# 5.7. Remove temporary rigid fix
unfix           rigid_temp

# 5.8. Initialize velocities
# Initialize with minimal rotational motion to favor translational collisions
# 'rot no' means no initial rotational velocity - translational motion will dominate
velocity        all create 0.6 12345 mom yes rot no

# 6. Dynamics
timestep        0.001000  # EXACT: 0.0002 (same as successful case) - avoids NaNs with strong Morse attractions

# 6.5. Use fix rigid/nvt with increased damping to reduce rotational momentum
# Increased damping (1.0) will strongly dissipate rotational energy, promoting translational motion
# This will reduce rotational momentum and increase head-on collisions
# Alternative: We could use fix nvt/rigid if available, but fix rigid/nvt is standard
fix             rigid_nvt all rigid/nvt molecule temp 0.6 0.6 1.0

# 7. Define groups for patches
group           patches_A type 2
group           patches_B type 3

# 8. Define coordination computes (required by fix state/change)
# Use tighter cutoff for coordination to require near-perfect patch overlap
compute         cA all coord/atom cutoff 0.34 group patches_A
compute         cB all coord/atom cutoff 0.34 group patches_B

# 9. Add state change fix (C++ fix - NO unfix/refix needed!)
# Syntax: fix ID group state/change check_every cooldown_steps probability cutoff group_A group_B
# Use coordination cutoff (not Morse cutoff) for state change detection - requires near-perfect overlap
fix             state_change all state/change 100 1000 0.7 0.34 patches_A patches_B

# 10. Output
thermo          5000
thermo_style    custom step temp pe ke etotal press f_state_change
dump            1 all custom 50000 dump.rigid_patchy_monomers.lammpstrj id mol type x y z
dump_modify     1 sort id

# 11. Run simulation
# State changes happen automatically during the run - no loop needed!
variable        final_step equal step
run             1000
variable        final_step equal step

print "Simulation finished. Total steps: ${final_step}"
